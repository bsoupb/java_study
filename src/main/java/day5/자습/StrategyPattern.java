package day5.자습;

/*
    전략 패턴

    [개요]
        - 알고리즘들의 집합을 정의
        - 각 알고리즘을 캡슐화하여 상호 교환 가능하게 만드는 디자인 패턴
        - 알고리즘을 사용하는 클라이언트와 알고리즘 구현 분리
        - 런타임에 알고리즘 변경 가능

    [구성요소]
        1. 전략 인터페이스 (Strategy Interface)
            - 모든 구체적인 전략 클래스가 구현해야 하는 공통 인터페이스
        2. 구체적인 전략 클래스 (Concrete Strategy)
            - 전략 인터페이스를 구현하는 실제 알고리즘 클래스
        3. 컨텍스트 클래스 (Context)
            - 전략 객체를 사용하는 클래스
            - 전략 인터페이스를 참조하는 변수를 가지고 있음

    [장점]
        1. 알고리즘 캡슐화
            - 코드 유지보수성 향상
            - 알고리즘의 내부 구현이 변경되어도 클라이언트 코드는 영향을 받지 않음
        2. 런타임 전략 변경
            - 실행 중에 사용하는 알고리즘을 동적으로 변경 가능
            - 조건에 따라 다른 전략을 선택할 수 있는 유연성 제공
        3. 새로운 전략 추가 용이
            - 기존 코드를 수정하지 않고 새로운 전략 추가 가능(OCP 원칙)
            ex) 새로운 결제 방법인 BitcoinPayment 추가 가능
        4. 상속 대신 합성 사용
            - 상속보다 더 유연한 방법으로 알고리즘 재사용
            - 불필요한 코드 중복 감소
    
    [단점]
        1. 클래스 수 증가
            - 각 알고리즘마다 별도의 클래스가 필요
            - 간단한 경우에는 오버헤드 될 수 있음
        2. 클라이언트가 전략을 알아야 함
            - 클라이언트가 적절한 전략을 선택하려면 전략 간의 차이점을 알아야 함
            - 전략 선택 로직이 복잡해질 수 있음
            
    [사용해야 할 때]
        1. 클래스가 다양한 알고리즘 변형을 구현해야 할 때
        2. 런타임에 알고리즘을 교체해야 할 때
        3. 알고리즘의 내부 데이터와 구현 세부 사항을 클라이언트로 숨기고 싶을 때
        4. 조건문이 많이 사용되는 코드를 간결하게 만들고 싶을 때
    
    [관련 패턴]
        - 템플릿 메소드 패턴: 알고리즘 구조는 동일, 일부 단계만 다른 경우에 사용
        - 상태 패턴: 객체의 상태에 따라 다른 동작을 수행해야할 때 사용 (전략 패턴과 구조는 유사하나 의도가 다름)
        - 명령 패턴: 작업을 캡슐화하여 다양한 요청을 처리할 때
 */


public class StrategyPattern {
}
